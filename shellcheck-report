#!/usr/bin/env bash
#
# Reports *.sh shellcheck issues in folder and all subfolders
# Author: Igor P. Zenkov
# Dependency: https://www.shellcheck.net CLI
#

declare -r SCRIPT_NAME="${0##*/}"
declare -r SCRIPT_VERSION='1.0.2 Jan 11, 2022'
declare -r FGLOB='*.sh'

function bold { echo -e "\e[96m$*\e[0m"; }
function err  { >&2 echo -e "$SCRIPT_NAME: \e[91m$*\e[0m"; }
function halt { err "$@"; exit 3; }

function assert_bash {
  local -r major="${BASH_VERSION:0:1}"
  ((major>=4)) || halt "Old Bash version $BASH_VERSION detected, please upgrade to a version 4.3 or newer"
}

function assert_shellcheck {
  shellcheck --help > /dev/null 2>&1 || halt 'shellcheck (www.shellcheck.net) not found'
}

function assert_dir {
  [[ -d $1 ]] || halt "folder '$1' not found"
}

function assert_cd {
  cd "$1" > /dev/null || halt "unable to chage folder to '$1'"
}

function check_file {
  shellcheck -x -f gcc "$1" | wc -l
}

# report all
function report_a {
  local -r dir=$1
  local -a scripts
  readarray -t scripts < <(find . -name "$FGLOB")
  local scr; local -i cnt total=0
  bold "$SCRIPT_NAME $SCRIPT_VERSION"
  echo
  echo "${PWD##*/}"
  echo
  for scr in "${scripts[@]}"; do
    cnt="$(check_file "$scr")"
    printf '%3d %s\n' "$cnt" "$scr"
    ((total+=cnt))
  done
  echo
  echo "$total issues in ${#scripts[@]} $FGLOB files"
}

# report all excluding scripts with 0 errors
function report_0 {
  local -r dir=$1
  local -a scripts
  readarray -t scripts < <(find . -name "$FGLOB")
  local scr; local -i cnt total=0 errcnt=0
  bold "$SCRIPT_NAME $SCRIPT_VERSION"
  echo
  echo "${PWD##*/}"
  echo
  for scr in "${scripts[@]}"; do
    cnt="$(check_file "$scr")"
    if ((cnt!=0)); then
      printf '%3d %s\n' "$cnt" "$scr"
      ((errcnt++))
    fi
    ((total+=cnt))
  done
  echo
  echo "$total issues in $errcnt $FGLOB files"
}

# report total error count
function report_c {
  local -r dir=$1
  local -a scripts
  readarray -t scripts < <(find . -name "$FGLOB")
  local scr; local -i cnt total=0
  for scr in "${scripts[@]}"; do
    cnt="$(check_file "$scr")"
    ((total+=cnt))
  done
  echo "$total"
}

# quiet mode, return exit code
function report_q {
  local -r dir=$1
  local -a scripts
  readarray -t scripts < <(find . -name "$FGLOB")
  local scr; local -i cnt total=0
  for scr in "${scripts[@]}"; do
    cnt="$(shellcheck -x -f gcc "$scr" | wc -l)"
    ((total+=cnt))
  done
  ((total==0)) || exit 1
}

function report {
  assert_shellcheck
  local -r dir=$1
  local -r opt=$2 # -0, -c, or -q
  local -a scripts
  readarray -t scripts < <(find . -name "$FGLOB")
  case $opt in
    -0) report_0 "$dir";;
    -c) report_c "$dir";;
    -q) report_q "$dir";;
     *) report_a "$dir";;
  esac
}

function report_dir {
  assert_dir "$1";
  assert_cd  "$1"
  report "$@"
  assert_cd '-'
}

function usage {
  bold "$SCRIPT_NAME $SCRIPT_VERSION"
  echo
  echo " Usage: $SCRIPT_NAME <dir>"
  echo "        $SCRIPT_NAME -0 <dir>"
  echo "        $SCRIPT_NAME -c <dir>"
  echo "        $SCRIPT_NAME -q <dir>"
  echo "        $SCRIPT_NAME -v"
  echo "        $SCRIPT_NAME -h"
  echo
  echo ' Where: <dir>  Folder to scan'
  echo '        -0     Exclude 0 errors scripts'
  echo '        -c     Print error count'
  echo '        -q     Quiet, return exit code'
  echo '        -v     Version'
  echo '        -h     Help'
  echo
  (($#==0)) && return
  echo " Like:  $SCRIPT_NAME ."
  echo "        $SCRIPT_NAME -0 ."
  echo "        $SCRIPT_NAME -c ."
  echo "        $SCRIPT_NAME -q ."
  echo "        $SCRIPT_NAME ./git"
  echo "        $SCRIPT_NAME ~/dev"
  echo
  echo ' Exit codes (-q option)'
  echo
  echo '  0: Folder scan completed with no issues'
  echo '  1: Folder scan completed with some issues'
  echo '  3: Bad syntax or options'
  echo
}

function one_arg {
  case $1 in
    -0|-c|-q) halt 'missing <dir> argument';;
    -h) usage '-h';;
    -v) echo "$SCRIPT_VERSION";;
    -*) halt "unknown argument '$1'";;
     *) report_dir "$1";;
  esac
}

function two_arg {
  case $1 in
    -0|-c|-q) report_dir "$2" "$1";; # reverse arguments: <dir> <opt>
    *) halt "unknown argument '$1'";;
  esac
}

function main {
  assert_bash
  case $# in
    0) usage;;
    1) one_arg "$@";;
    2) two_arg "$@";;
    *) halt 'too many arguments';;
  esac
}

main "$@"
